#! /bin/sh
#
# Performance-testing script.
#
# Run this script with the name of a pcap file and the name of a core,
# as in
#
#	./perfscript test.pcap panda
#
# and it will compute a performance estimate for the core for the
# workload in the pcap.  It will compute a -n value which approximates
# one hundred million packets total, based on the number of packets in the
# pcap file.
#
# This script depends on various utilities.  Specifically, it expects
# to use nine external programs, which it expects to find on $PATH:
#	mktemp(1)
#	rm(1)
#	tcpdump(8)
#	wc(1)
#	egrep(1)
#	sed(1)
#	cat(1)
#	time(1) (see below for more on this one!)
#	dc(1)
#  and a few other programs which are normally shell builtins, even
#  though they don't, strictly speaking, have to be:
#	echo [ :
#  and various other commands which inherently must be shell builtins,
#  such as if and umask.
#
# Note that time(1) can be especially problematic; just because "time
# COMMAND" works for you doesn't mean you've got time(1).  Many shells
# have a `time' builtin; this script often will not find that builtin
# because the script is run by a different shell; in at least some
# cases, the builtin is not suitable - for example, at least one
# version of bash has a time builtin, but it does not support -f and
# thus it does not work to just change the #! to /bin/bash if you have
# that version of bash.  There are probably other shells, probably
# including some other versions of bash, with similar issues.
#

usage() {
	echo "Usage: $0 pcap-file dissector-core" 1>&2
	echo "as in" 1>&2
	echo "$0 test.pcap panda" 1>&2
}

case $# in
	2)	pcap="$1"
		core="$2"
		;;
	*)	usage
		exit 1
		;;
esac

n=1
m=`umask`
umask=077
d=`mktemp -d -p /tmp`
umask $m

if [ ! -d $d ]; then
	echo "mktemp -d -p /tmp returned "\""$d"\"", which isn't a directory!" \
		1>&2
	exit 1
fi

trap "rm -rf $d; exit" 0 1 2 15

(exec 3>&1; tcpdump -n -r "$pcap" 2>&3 | wc -l > $d/td-o) | egrep -v \
	'^reading from file ' > $d/td-e

if [ -s $d/td-e ]; then
	exec 1>&2
	echo "Error output from tcpdump -r $pcap":
	sed -e 's/^/	/' < $d/td-e
	exit 1
fi

rm $d/td-e

n=`cat $d/td-o`
rm $d/td-o
if [ $n -lt 1 ]; then
	exec 1>&2
	echo "$pcap appears to contain no packets!"
	exit 1
fi
r=$((100000000 / $n))

./test_parser -i pcap,$pcap -c $core -o null > $d/one.out 2> $d/one.err
maybe=:
if [ -s $d/one.out ]; then
	exec 1>&2
	echo Test parser run stdout:
	sed -e 's/^/	/' < $d/one.out
	maybe=
fi
if [ -s $d/one.err ]; then
	exec 1>&2
	echo Test parser run stderr:
	sed -e 's/^/	/' < $d/one.err
	maybe=
fi
$maybe exit 1

echo -n "Time: "
with=`time -f %e ./test_parser -n $r -i pcap,$pcap -c $core -o null 2>&1`
echo -n "$with - "
without=`time -f %e ./test_parser -N -n $r -i pcap,$pcap -c $core -o null 2>&1`
echo -n "$without = "
delta=`echo $with $without - p | dc`
echo -n "$delta, for "
# delta is seconds; convert to ns and divide by packet count -> ns per packet
ns=`echo 4 k $delta 1000000000 \* $n $r \* / p | dc`
pps=`echo 2 k 1000000000 $ns / p | dc`
echo "$ns ns/packet, $pps packets/sec"
